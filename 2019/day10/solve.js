// Generated by CoffeeScript 2.4.1
(function() {
  var AsteroidField, findGCD, fs, input, one, out;

  fs = require('fs');

  input = fs.readFileSync('input.txt', 'utf-8').replace(/\n$/, "");

  findGCD = function(x, y) {
    var remain;
    x = Math.abs(x);
    y = Math.abs(y);
    while (y) {
      remain = x % y;
      x = y;
      y = remain;
    }
    return x;
  };

  AsteroidField = class AsteroidField {
    constructor(raw) {
      var line;
      this.grid = (function() {
        var j, len, ref, results;
        ref = raw.split("\n");
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          line = ref[j];
          results.push(Array.from(line));
        }
        return results;
      })();
      this.names = {};
      this.asteroids = this._findAsteroids();
    }

    _findAsteroids() {
      var char, cn, j, k, len, len1, ref, rn, row, rs;
      rs = [];
      ref = this.grid;
      for (rn = j = 0, len = ref.length; j < len; rn = ++j) {
        row = ref[rn];
        for (cn = k = 0, len1 = row.length; k < len1; cn = ++k) {
          char = row[cn];
          if (char === "#") {
            rs.push([cn, rn]);
          }
        }
        this.max_x = cn - 1;
      }
      this.max_y = rn - 1;
      return rs;
    }

    print() {
      var b, char, j, k, len, len1, n, names, ref, row;
      names = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      n = 0;
      b = [];
      ref = this.grid;
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        for (k = 0, len1 = row.length; k < len1; k++) {
          char = row[k];
          if (char === "#") {
            b.push(names[n++]);
          } else {
            b.push(char);
          }
        }
        b.push("\n");
      }
      return console.log(b.join(""));
    }

    asteroidWouldBlock(start, ex) {
      var blocked_x, blocked_y, dx, dy, gcd, mult, results, slope_x, slope_y;
      dx = ex[0] - start[0];
      dy = ex[1] - start[1];
      gcd = findGCD(dx, dy);
      slope_x = dx / gcd;
      slope_y = dy / gcd;
      mult = 1;
      results = [];
      while (true) {
        blocked_x = slope_x * mult + ex[0];
        blocked_y = slope_y * mult + ex[1];
        if (blocked_x > this.max_x || blocked_x < 0) {
          break;
        }
        if (blocked_y > this.max_y || blocked_y < 0) {
          break;
        }
        mult += 1;
        results.push([blocked_x, blocked_y]);
      }
      return results;
    }

    otherAsteroids(thisOne) {
      var a, j, len, ref, results;
      ref = this.asteroids;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        if (!this.isSame(thisOne, a)) {
          results.push(a);
        }
      }
      return results;
    }

    isSame(a, b) {
      return a[0] === b[0] && a[1] === b[1];
    }

    solve() {
      var ast, blockedVis, count, j, k, l, len, len1, len2, most, o, ref, ref1, ref2, view;
      count = new Map();
      ref = this.asteroids;
      for (j = 0, len = ref.length; j < len; j++) {
        ast = ref[j];
        blockedVis = [];
        view = 0;
        ref1 = this.otherAsteroids(ast);
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          o = ref1[k];
          blockedVis = blockedVis.concat(this.asteroidWouldBlock(ast, o));
        }
        ref2 = this.otherAsteroids(ast);
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          o = ref2[l];
          if (!blockedVis.some((z) => {
            return this.isSame(o, z);
          })) {
            view++;
          }
        }
        count.set(JSON.stringify(ast), view);
      }
      most = [...count.entries()].reduce((high, k_v) => {
        if (k_v[1] > high[1]) {
          return k_v;
        } else {
          return high;
        }
      });
      return most;
    }

  };

  out = function(a) {
    return console.log(JSON.stringify(a));
  };

  one = function(i) {
    var f;
    f = new AsteroidField(i);
    return out(f.solve());
  };

  one(input);

}).call(this);

//# sourceMappingURL=solve.js.map
