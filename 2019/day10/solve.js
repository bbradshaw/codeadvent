// Generated by CoffeeScript 2.4.1
(function() {
  var AsteroidField, PolarAsteroids, ans, findGCD, fs, input, one, start, two;

  fs = require('fs');

  input = fs.readFileSync('input.txt', 'utf-8').replace(/\n$/, "");

  findGCD = function(x, y) {
    var remain;
    x = Math.abs(x);
    y = Math.abs(y);
    while (y) {
      remain = x % y;
      x = y;
      y = remain;
    }
    return x;
  };

  AsteroidField = class AsteroidField {
    constructor(raw) {
      var line;
      this.grid = (function() {
        var j, len, ref, results;
        ref = raw.split("\n");
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          line = ref[j];
          results.push(Array.from(line));
        }
        return results;
      })();
      this.names = {};
      this.asteroids = this._findAsteroids();
    }

    _findAsteroids() {
      var char, cn, j, k, len, len1, ref, rn, row, rs;
      rs = [];
      ref = this.grid;
      for (rn = j = 0, len = ref.length; j < len; rn = ++j) {
        row = ref[rn];
        for (cn = k = 0, len1 = row.length; k < len1; cn = ++k) {
          char = row[cn];
          if (char === "#") {
            rs.push([cn, rn]);
          }
        }
        this.max_x = cn - 1;
      }
      this.max_y = rn - 1;
      return rs;
    }

    print() {
      var b, char, j, k, len, len1, n, names, ref, row;
      names = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      n = 0;
      b = [];
      ref = this.grid;
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        for (k = 0, len1 = row.length; k < len1; k++) {
          char = row[k];
          if (char === "#") {
            b.push(names[n++]);
          } else {
            b.push(char);
          }
        }
        b.push("\n");
      }
      return console.log(b.join(""));
    }

    asteroidWouldBlock(start, ex) {
      var blocked_x, blocked_y, dx, dy, gcd, mult, results, slope_x, slope_y;
      dx = ex[0] - start[0];
      dy = ex[1] - start[1];
      gcd = findGCD(dx, dy);
      slope_x = dx / gcd;
      slope_y = dy / gcd;
      mult = 1;
      results = [];
      while (true) {
        blocked_x = slope_x * mult + ex[0];
        blocked_y = slope_y * mult + ex[1];
        if (blocked_x > this.max_x || blocked_x < 0) {
          break;
        }
        if (blocked_y > this.max_y || blocked_y < 0) {
          break;
        }
        mult += 1;
        results.push([blocked_x, blocked_y]);
      }
      return results;
    }

    otherAsteroids(thisOne) {
      var a, j, len, ref, results;
      ref = this.asteroids;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        if (!this.isSame(thisOne, a)) {
          results.push(a);
        }
      }
      return results;
    }

    isSame(a, b) {
      return a[0] === b[0] && a[1] === b[1];
    }

    solve() {
      var ast, blockedVis, count, j, k, l, len, len1, len2, most, o, ref, ref1, ref2, view;
      count = new Map();
      ref = this.asteroids;
      for (j = 0, len = ref.length; j < len; j++) {
        ast = ref[j];
        blockedVis = [];
        view = 0;
        ref1 = this.otherAsteroids(ast);
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          o = ref1[k];
          blockedVis = blockedVis.concat(this.asteroidWouldBlock(ast, o));
        }
        ref2 = this.otherAsteroids(ast);
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          o = ref2[l];
          if (!blockedVis.some((z) => {
            return this.isSame(o, z);
          })) {
            view++;
          }
        }
        count.set(JSON.stringify(ast), view);
      }
      most = Array.from(count.entries()).reduce((high, k_v) => {
        if (k_v[1] > high[1]) {
          return k_v;
        } else {
          return high;
        }
      });
      return most;
    }

  };

  PolarAsteroids = class PolarAsteroids {
    constructor(af, coordinate) {
      var ast, distance, j, len, ref;
      this.xlate = new Map;
      ref = af.asteroids;
      for (j = 0, len = ref.length; j < len; j++) {
        ast = ref[j];
        this.relx = ast[0] - coordinate[0];
        this.rely = ast[1] - coordinate[1];
        distance = Math.abs(this.relx) + Math.abs(this.rely);
        this.xlate.set(JSON.stringify([distance, this.relx, this.rely]), ast);
      }
    }

    solve() {
      var ang, angle, angles, asteroidDestroyed, coordinate, coordinates, distance, i, j, k, l, len, len1, len2, len3, m, nxt, q, r, ref, ref1, ref2, rotation, x, y;
      coordinates = [];
      ref = this.xlate.keys();
      for (coordinate of ref) {
        [distance, x, y] = JSON.parse(coordinate);
        if (x !== 0 || y !== 0) {
          coordinates.push([distance, x, y]);
        }
      }
      rotation = [new Map, new Map];
      for (j = 0, len = coordinates.length; j < len; j++) {
        [distance, x, y] = coordinates[j];
        if (x >= 0) {
          rotation[0].set(y / x, []);
        } else {
          rotation[1].set(y / x, []);
        }
      }
      angles = [Array.from(rotation[0].keys()), Array.from(rotation[1].keys())];
      angles[0].sort((a, b) => {
        return b - a;
      });
      angles[1].sort((a, b) => {
        return a - b;
      });
      for (k = 0, len1 = coordinates.length; k < len1; k++) {
        [distance, x, y] = coordinates[k];
        if (x >= 0) {
          rotation[0].get(y / x).push([distance, x, y]);
        } else {
          rotation[1].get(y / x).push([distance, x, y]);
        }
      }
      for (i = l = 0; l <= 1; i = ++l) {
        ref1 = angles[i];
        for (m = 0, len2 = ref1.length; m < len2; m++) {
          ang = ref1[m];
          rotation[i].get(ang).sort((a, b) => {
            return a[0] - b[0];
          });
        }
      }
      console.log(`total angles: ${angles[0].length + angles[1].length}`);
      asteroidDestroyed = 0;
      while (asteroidDestroyed < 201) {
        for (i = q = 0; q <= 1; i = ++q) {
          ref2 = angles[i];
          for (r = 0, len3 = ref2.length; r < len3; r++) {
            angle = ref2[r];
            nxt = rotation[i].get(angle).shift();
            if (nxt != null) {
              asteroidDestroyed++;
              console.log(`asteroid at relative coord [${JSON.stringify(this.xlate.get(JSON.stringify(nxt)))}] destroyed (${asteroidDestroyed}) with slope ${angle}`);
              if (asteroidDestroyed === 200) {
                return this.xlate.get(JSON.stringify(nxt));
              }
            }
          }
          console.log("next half");
        }
      }
    }

  };

  one = function(i) {
    var f;
    f = new AsteroidField(i);
    return f.solve();
  };

  two = function(i, x, y) {
    var ans, f, p;
    f = new AsteroidField(i);
    p = new PolarAsteroids(f, [x, y]);
    ans = p.solve();
    return ans[0] * 100 + ans[1];
  };

  ans = one(input);

  console.log(ans);

  start = JSON.parse(ans[0]);

  two(input, start[0], start[1]);

  //two input, 11, 13

}).call(this);

//# sourceMappingURL=solve.js.map
